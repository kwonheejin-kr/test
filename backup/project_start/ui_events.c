//주의 사항*
//humidifier은 label ui, smog는 event 이름으로 혼동의 요소가 강함


// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 9.1.0
// Project name: SquareLine_Project_change

#include "ui.h"
#include "lvgl.h"
#include "ui_events.h"
#include "BluetoothSerial.h"
#include "Wire.h"
#include "DHT.h"
#include "Adafruit_MAX30102.h"
#include "WiFi.h"
#include "FS.h"
#include "SD.h"
#include "SPI.h"
#include "driver/i2s.h"
#include "sd_utils.h"

#define SD_CS 13  // SD 카드 칩 셀렉트 핀
#define WIFI_SSID "YOUR_WIFI_SSID"
#define WIFI_PASSWORD "YOUR_WIFI_PASSWORD"
#define SERVER_IP "192.168.1.100"  // 라즈베리파이 IP
#define DHT_PIN 4
#define DHT_TYPE DHT22
#define SLAVE_ADDR 0x08
#define I2S_NUM I2S_NUM_0
#define MUSIC_FILE_PATH "/music.wav"

DHT dht(DHT_PIN, DHT_TYPE);
Adafruit_MAX30102 heartRateSensor;
bool is_measuring = false;
unsigned long start_time = 0;
File heartDataFile;
File musicFile;
bool isPlaying = false;
extern BluetoothSerial SerialBT; //블루투스 객체

//라즈베리파이에 데이터 전송하는 내용



//블루투스 연결 상태 확인용 타이머 핸들러

lv_timer_t * bt_timer= NULL;
unsigned long bt_start_time = 0; //bluetooth for millis

//fan toggle millis 구조

unsigned long fan_last_request = 0;
bool fan_request_pending = false;

//led toggle millis

unsigned long led_last_request = 0;
bool led_request_pending = false;

//smog toggle millis
unsigned long smog_last_request = 0;
bool smog_request_pending = false;

void request_fan_status(lv_timer_t * timer) {
    if (fan_request_pending && millis() - fan_last_request >= 100) {
        Wire.requestFrom(SLAVE_ADDR, 1);  
        unsigned long start_wait = millis();
        while (!Wire.available() && millis() - start_wait < 50);  // 최대 50ms 대기

        if (Wire.available()) {
            char fan_state = Wire.read();
            lv_label_set_text(ui_fan, (fan_state == '1') ? "Fan ON" : "Fan OFF");
            Serial.print("팬 상태 업데이트: ");
            Serial.println(fan_state == '1' ? "ON" : "OFF");
        } else {
            Serial.println("팬 상태 요청 실패: 응답 없음.");
        }

        fan_request_pending = false;
    }
}

void fan_toggle(lv_event_t * e)
{
    Serial.println("팬 토글 명령 전송...");
    Wire.beginTransmission(SLAVE_ADDR);
    Wire.write('T');
    Wire.endTransmission();

    fan_last_request = millis();  
    fan_request_pending = true;

    // 상태 확인 요청을 일정 시간 뒤에 수행하도록 타이머 추가
    lv_timer_create(request_fan_status, 300, NULL);  // 300ms 후 상태 확인
}


void request_smog_status(lv_timer_t * timer) {
    if (millis() - smog_last_request >= 100 && smog_request_pending) {
        Wire.requestFrom(SLAVE_ADDR, 1);  // 슬레이브에서 스모그 상태 요청
        if (Wire.available()) {
            char smog_state = Wire.read();
            lv_label_set_text(ui_humidifier, (smog_state == '1') ? "Smog ON" : "Smog OFF");
            Serial.print("스모그 상태 업데이트: ");
            Serial.println(smog_state == '1' ? "ON" : "OFF");
        }
        smog_request_pending = false;  // 요청 완료
    }
}

void toggle_smog(lv_event_t * e)
{
	Serial.println("가습기 토글 명령 전송...");
    Wire.beginTransmission(SLAVE_ADDR);
    Wire.write('H');  // 'H' (Humidifier Toggle) 명령 전송
    Wire.endTransmission();
    
    smog_last_request = millis();  // 마지막 요청 시간 기록
    smog_request_pending = true;  // 가습기 상태 요청 예약
}

void request_led_status(lv_timer_t * timer) {
    if (millis() - led_last_request >= 100 && led_request_pending) {
        Wire.requestFrom(SLAVE_ADDR, 1);  // 슬레이브에서 LED 상태 요청
        if (Wire.available()) {
            char led_state = Wire.read();
            lv_label_set_text(ui_led, (led_state == '1') ? "LED ON" : "LED OFF");
            Serial.print("LED 상태 업데이트: ");
            Serial.println(led_state == '1' ? "ON" : "OFF");
        }
        led_request_pending = false;  // 요청 완료
    }
}


void toggle_led(lv_event_t * e)
{
	Serial.println("LED 토글 명령 전송...");
    Wire.beginTransmission(SLAVE_ADDR);
    Wire.write('L');  // 'L' (LED Toggle) 명령 전송
    Wire.endTransmission();
    
    led_last_request = millis();  // 마지막 요청 시간 기록
    led_request_pending = true;  // LED 상태 요청 예약
}


void send_data_to_raspberry() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi 연결 안 됨.");
        return;
    }

    WiFiClient client;
    if (!client.connect(SERVER_IP, 5000)) {
        Serial.println("라즈베리파이 연결 실패.");
        return;
    }

    Serial.println("라즈베리파이와 연결됨. 데이터 전송 시작...");
    File file = SD.open("/heartDATA/heart_data.txt");

    if (!file) {
        Serial.println("파일 열기 실패.");
        client.stop();
        return;
    }

    while (file.available()) {
        uint8_t buffer[512];
        size_t bytesRead = file.read(buffer, sizeof(buffer));
        client.write(buffer, bytesRead);  // 데이터 패킷 단위 전송
    }

    file.close();
    client.stop();
    Serial.println("데이터 전송 완료.");
}



void save_heart_data(float bpm) {
    if (!SD.exists("/heartDATA")) {
        SD.mkdir("/heartDATA");
    }
    heartDataFile = SD.open("/heartDATA/heart_data.txt", FILE_APPEND);
    if (heartDataFile) {
        heartDataFile.print(millis());
        heartDataFile.print(", ");
        heartDataFile.println(bpm);
        heartDataFile.close();
    }
}


void HeartBeatMeasuringStart(lv_event_t * e)
{
    Serial.println("HeartMeasuring 화면 로드됨, 'Touch Plz' 표시.");
    lv_label_set_text(ui_Measuring, "Touch Plz");

    start_time = millis();
    is_measuring = false;
}

void measure_heart_rate(lv_timer_t * timer) {
    if (millis() - start_time >= 5000) {  // 5초 경과 시 측정 종료
        Serial.println("심박수 측정 완료.");
        lv_label_set_text(ui_Measuring, "Finish!");
        lv_timer_del(timer);
        send_data_to_raspberry();
        is_measuring = false;
        return;
    }

    float heartRate = heartRateSensor.getHeartRate();
    if (!isnan(heartRate) && heartRate > 0) {
        Serial.print("심박수: ");
        Serial.println(heartRate);
        save_heart_data(heartRate);
    }
}

void check_sensor_data(lv_timer_t * timer) {
    float heartRate = heartRateSensor.getHeartRate();
    if (!isnan(heartRate) && heartRate > 0 && !is_measuring) {
        Serial.println("심박수 데이터 감지됨. 측정 시작!");
        lv_label_set_text(ui_Measuring, "Measuring...");
        is_measuring = true;
        start_time = millis();
        lv_timer_create(measure_heart_rate, 500, NULL);
    }
}


//bluetooth connect code

void start_bluetooth_status(lv_timer_t * timer)  
{
	static int retry_count = 0;

	if (SerialBT.hasClient()) {
		Serial.println("블루투스 연결 성공!");
		lv_label_set_text(ui_bluetoothLabel, "Connect Success!");
		lv_timer_del(bt_timer);
	} else {
		retry_count++;
		if (retry_count < 10) {  // 최대 10회 재시도
			Serial.println("블루투스 재시도 중...");
		} else {
			Serial.println("블루투스 연결 실패!");
			lv_label_set_text(ui_bluetoothLabel, "Connect Fail!");
			lv_timer_del(bt_timer);
		}
	}
}


void start_bluetooth_connection(lv_event_t * e){
	Serial.print("블루투스 연결 시도...");
	lv_label_set_text(ui_bluetoothLabel, "Connecting...")
	
	bt_start_time = millis();
	bt_timer = lv_timer_create(start_bluetooth_status, 100, NULL);
}

void play_touch_sound() {
    File audioFile = SD.open("/touch.wav");
    if (!audioFile) {
        Serial.println("❌ 터치 사운드 파일을 찾을 수 없습니다");
        return;
    }

    Serial.println("🔊 터치 사운드 재생 시작");
    
    // I2S를 통한 오디오 재생
    size_t bytesWritten = 0;
    uint8_t buffer[1024];
    while (audioFile.available()) {
        size_t bytesRead = audioFile.read(buffer, sizeof(buffer));
        i2s_write(I2S_NUM_0, buffer, bytesRead, &bytesWritten, portMAX_DELAY);
    }
    
    audioFile.close();
    Serial.println("✅ 터치 사운드 재생 완료");
}

// 모든 버튼의 공통 이벤트 핸들러
void common_button_event_handler(lv_event_t * e) {
    lv_event_code_t code = lv_event_get_code(e);
    if(code == LV_EVENT_CLICKED) {
        play_touch_sound();
    }
}

void on_button_pressed(lv_event_t * e) {
    Serial.println("🖲 버튼 터치됨, 효과음 실행!");
    play_touch_sound();  // 🔊 효과음 재생
}

void hide_home_button(lv_event_t * e)
{
	// Your code here
}

void update_temp_hum(lv_timer_t * timer) {
    float temp = dht.readTemperature();
    float hum = dht.readHumidity();

    if (!isnan(temp) && !isnan(hum)) {  // 유효한 값이 있는 경우에만 UI 업데이트
        static char temp_text[16];
        static char hum_text[16];
        sprintf(temp_text, "%.1f °C", temp);
        sprintf(hum_text, "%.1f %%", hum);

        lv_label_set_text(ui_tempData, temp_text);
        lv_label_set_text(ui_humData, hum_text);
        lv_bar_set_value(ui_tempBar, (int)temp, LV_ANIM_ON);
        lv_bar_set_value(ui_humBar, (int)hum, LV_ANIM_ON);

        Serial.print("온도: ");
        Serial.print(temp);
        Serial.print(" °C, 습도: ");
        Serial.print(hum);
        Serial.println(" %");
    }
}

void update_Sensor_Data(lv_event_t * e)
{
    Serial.println("홈 화면 로드 완료 - 온습도 데이터 수집 시작...");
    dht.begin();
    lv_timer_create(update_temp_hum, 2000, NULL);
}

