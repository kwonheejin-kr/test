//주의 사항*
//humidifier은 label ui, smog는 event 이름으로 혼동의 요소가 강함


// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 9.1.0
// Project name: SquareLine_Project_change

#include "ui.h"
#include "lvgl.h"
#include "ui_events.h"
#include "BluetoothSerial.h"
#include "Wire.h"
#include "DHT.h"
#include "Adafruit_MAX30102.h"
#include "WiFi.h"
#include "FS.h"
#include "SD.h"
#include "SPI.h"
#include "driver/i2s.h"

#define SD_CS 13  // SD 카드 칩 셀렉트 핀
#define WIFI_SSID "YOUR_WIFI_SSID"
#define WIFI_PASSWORD "YOUR_WIFI_PASSWORD"
#define SERVER_IP "192.168.1.100"  // 라즈베리파이 IP
#define DHT_PIN 4
#define DHT_TYPE DHT22
#define SLAVE_ADDR 0x08
#define I2S_NUM I2S_NUM_0
#define MUSIC_FILE_PATH "/music.wav"

DHT dht(DHT_PIN, DHT_TYPE);
Adafruit_MAX30102 heartRateSensor;
bool is_measuring = false;
unsigned long start_time = 0;
File heartDataFile;
File musicFile;
bool isPlaying = false;
extern BluetoothSerial SerialBT; //블루투스 객체

//라즈베리파이에 데이터 전송하는 내용



//블루투스 연결 상태 확인용 타이머 핸들러

lv_timer_t * bt_timer= NULL;
unsigned long bt_start_time = 0; //bluetooth for millis

//fan toggle millis 구조

unsigned long fan_last_request = 0;
bool fan_request_pending = false;

//led toggle millis

unsigned long led_last_request = 0;
bool led_request_pending = false;

//smog toggle millis
unsigned long smog_last_request = 0;
bool smog_request_pending = false;

void request_fan_status(lv_timer_t * timer) {
    if (fan_request_pending && millis() - fan_last_request >= 100) {
        Wire.requestFrom(SLAVE_ADDR, 1);  
        unsigned long start_wait = millis();
        while (!Wire.available() && millis() - start_wait < 50);  // 최대 50ms 대기

        if (Wire.available()) {
            char fan_state = Wire.read();
            lv_label_set_text(ui_fan, (fan_state == '1') ? "Fan ON" : "Fan OFF");
            Serial.print("팬 상태 업데이트: ");
            Serial.println(fan_state == '1' ? "ON" : "OFF");
        } else {
            Serial.println("팬 상태 요청 실패: 응답 없음.");
        }

        fan_request_pending = false;
    }
}

void fan_toggle(lv_event_t * e)
{
    Serial.println("팬 토글 명령 전송...");
    Wire.beginTransmission(SLAVE_ADDR);
    Wire.write('T');
    Wire.endTransmission();

    fan_last_request = millis();  
    fan_request_pending = true;

    // 상태 확인 요청을 일정 시간 뒤에 수행하도록 타이머 추가
    lv_timer_create(request_fan_status, 300, NULL);  // 300ms 후 상태 확인
}


void request_smog_status(lv_timer_t * timer) {
    if (millis() - smog_last_request >= 100 && smog_request_pending) {
        Wire.requestFrom(SLAVE_ADDR, 1);  // 슬레이브에서 스모그 상태 요청
        if (Wire.available()) {
            char smog_state = Wire.read();
            lv_label_set_text(ui_humidifier, (smog_state == '1') ? "Smog ON" : "Smog OFF");
            Serial.print("스모그 상태 업데이트: ");
            Serial.println(smog_state == '1' ? "ON" : "OFF");
        }
        smog_request_pending = false;  // 요청 완료
    }
}

void toggle_smog(lv_event_t * e)
{
	Serial.println("가습기 토글 명령 전송...");
    Wire.beginTransmission(SLAVE_ADDR);
    Wire.write('H');  // 'H' (Humidifier Toggle) 명령 전송
    Wire.endTransmission();
    
    smog_last_request = millis();  // 마지막 요청 시간 기록
    smog_request_pending = true;  // 가습기 상태 요청 예약
}

void request_led_status(lv_timer_t * timer) {
    if (millis() - led_last_request >= 100 && led_request_pending) {
        Wire.requestFrom(SLAVE_ADDR, 1);  // 슬레이브에서 LED 상태 요청
        if (Wire.available()) {
            char led_state = Wire.read();
            lv_label_set_text(ui_led, (led_state == '1') ? "LED ON" : "LED OFF");
            Serial.print("LED 상태 업데이트: ");
            Serial.println(led_state == '1' ? "ON" : "OFF");
        }
        led_request_pending = false;  // 요청 완료
    }
}


void toggle_led(lv_event_t * e)
{
	Serial.println("LED 토글 명령 전송...");
    Wire.beginTransmission(SLAVE_ADDR);
    Wire.write('L');  // 'L' (LED Toggle) 명령 전송
    Wire.endTransmission();
    
    led_last_request = millis();  // 마지막 요청 시간 기록
    led_request_pending = true;  // LED 상태 요청 예약
}


void send_data_to_raspberry() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi 연결 안 됨.");
        return;
    }

    WiFiClient client;
    if (!client.connect(SERVER_IP, 5000)) {
        Serial.println("라즈베리파이 연결 실패.");
        return;
    }

    Serial.println("라즈베리파이와 연결됨. 데이터 전송 시작...");
    File file = SD.open("/heartDATA/heart_data.txt");

    if (!file) {
        Serial.println("파일 열기 실패.");
        client.stop();
        return;
    }

    while (file.available()) {
        uint8_t buffer[512];
        size_t bytesRead = file.read(buffer, sizeof(buffer));
        client.write(buffer, bytesRead);  // 데이터 패킷 단위 전송
    }

    file.close();
    client.stop();
    Serial.println("데이터 전송 완료.");
}



void save_heart_data(float bpm) {
    if (!SD.exists("/heartDATA")) {
        SD.mkdir("/heartDATA");
    }
    heartDataFile = SD.open("/heartDATA/heart_data.txt", FILE_APPEND);
    if (heartDataFile) {
        heartDataFile.print(millis());
        heartDataFile.print(", ");
        heartDataFile.println(bpm);
        heartDataFile.close();
    }
}


void ui_event_start_measuring(lv_event_t * e) {
    lv_obj_t * target = lv_event_get_target(e);
    if (lv_event_get_code(e) == LV_EVENT_CLICKED) {
        // 측정 시작 시 UI 업데이트
        lv_label_set_text(ui_Measuring, "측정 중...");
        
        // 측정 타이머 시작 (5초)
        static lv_timer_t * measure_timer = NULL;
        if (measure_timer == NULL) {
            measure_timer = lv_timer_create(measure_heart_rate, 100, NULL);
            lv_timer_set_repeat_count(measure_timer, 50); // 5초 (50 * 100ms)
        }
    }
}

// 전역 변수 선언
static uint32_t red_buffer[100];
static uint32_t ir_buffer[100];
static uint8_t buffer_index = 0;
static bool measuring = false;
static int32_t heart_rate = 0;
static int32_t spo2_value = 0;

void measure_heart_rate(lv_timer_t * timer) {
    static int progress = 0;
    
    if (progress == 0) {
        // 측정 시작 시 초기화
        buffer_index = 0;
        measuring = true;
        particleSensor.setup(60, 4, 2, 411, 4096);
    }
    
    if (measuring && buffer_index < 100) {
        // 센서에서 데이터 읽기
        while (particleSensor.available()) {
            red_buffer[buffer_index] = particleSensor.getRed();
            ir_buffer[buffer_index] = particleSensor.getIR();
            particleSensor.nextSample();
            
            buffer_index++;
            if (buffer_index >= 100) break;
        }
    }
    
    progress += 2; // 2% 증가
    char progress_text[32];
    snprintf(progress_text, sizeof(progress_text), "측정 중... %d%%", progress);
    lv_label_set_text(ui_Measuring, progress_text);
    
    if (progress >= 100) {
        // 측정 완료
        measuring = false;
        int8_t valid_spo2, valid_hr;
        maxim_heart_rate_and_oxygen_saturation(ir_buffer, 100, red_buffer, &spo2_value, &valid_spo2, &heart_rate, &valid_hr);
        
        char result_text[64];
        if (valid_hr && valid_spo2) {
            snprintf(result_text, sizeof(result_text), "심박수: %ld bpm\nSpO2: %ld%%", heart_rate, spo2_value);
            
            // SD 카드에 데이터 저장
            save_measurement_data(heart_rate, spo2_value);
        } else {
            snprintf(result_text, sizeof(result_text), "측정 실패\n다시 시도해주세요");
        }
        
        lv_label_set_text(ui_HeartResult, result_text);
        lv_label_set_text(ui_Measuring, "터치하여 측정 시작");
        
        // 타이머 정리
        lv_timer_del(timer);
    }
}

void save_measurement_data(int32_t hr, int32_t spo2) {
    File dataFile = SD.open("/measurements.csv", FILE_APPEND);
    if (dataFile) {
        char timestamp[20];
        time_t now;
        time(&now);
        strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
        
        char data_line[64];
        snprintf(data_line, sizeof(data_line), "%s,%ld,%ld\n", timestamp, hr, spo2);
        dataFile.print(data_line);
        dataFile.close();
    }
}

void HeartBeatMeasuringStart(lv_event_t * e)
{
    Serial.println("HeartMeasuring 화면 로드됨, 'Touch Plz' 표시.");
    lv_label_set_text(ui_Measuring, "Touch Plz");

    start_time = millis();
    is_measuring = false;
}

void check_sensor_data(lv_timer_t * timer) {
    float heartRate = heartRateSensor.getHeartRate();
    if (!isnan(heartRate) && heartRate > 0 && !is_measuring) {
        Serial.println("심박수 데이터 감지됨. 측정 시작!");
        lv_label_set_text(ui_Measuring, "Measuring...");
        is_measuring = true;
        start_time = millis();
        lv_timer_create(measure_heart_rate, 500, NULL);
    }
}


//bluetooth connect code

void start_bluetooth_status(lv_timer_t * timer)  
{
	static int retry_count = 0;

	if (SerialBT.hasClient()) {
		Serial.println("블루투스 연결 성공!");
		lv_label_set_text(ui_bluetoothLabel, "Connect Success!");
		lv_timer_del(bt_timer);
	} else {
		retry_count++;
		if (retry_count < 10) {  // 최대 10회 재시도
			Serial.println("블루투스 재시도 중...");
		} else {
			Serial.println("블루투스 연결 실패!");
			lv_label_set_text(ui_bluetoothLabel, "Connect Fail!");
			lv_timer_del(bt_timer);
		}
	}
}


void start_bluetooth_connection(lv_event_t * e){
	Serial.print("블루투스 연결 시도...");
	lv_label_set_text(ui_bluetoothLabel, "Connecting...")
	
	bt_start_time = millis();
	bt_timer = lv_timer_create(start_bluetooth_status, 100, NULL);
}

void play_touch_sound() {
    File audioFile = SD.open(AUDIO_FILE_PATH);  // 효과음 파일 열기
    if (!audioFile) {
        Serial.println("❌ 효과음 파일을 찾을 수 없습니다!");
        return;
    }

    Serial.println("🔊 효과음 재생 시작...");

    uint8_t buffer[1024];
    while (audioFile.available()) {
        size_t bytesRead = audioFile.read(buffer, sizeof(buffer));
        i2s_write(I2S_NUM, buffer, bytesRead, NULL, portMAX_DELAY);
    }

    audioFile.close();
    Serial.println("✅ 효과음 재생 완료.");
}

void on_button_pressed(lv_event_t * e) {
    Serial.println("🖲 버튼 터치됨, 효과음 실행!");
    play_touch_sound();  // 🔊 효과음 재생
}

void hide_home_button(lv_event_t * e)
{
	// Your code here
}

void update_temp_hum(lv_timer_t * timer) {
    float temp = dht.readTemperature();
    float hum = dht.readHumidity();

    if (!isnan(temp) && !isnan(hum)) {  // 유효한 값이 있는 경우에만 UI 업데이트
        static char temp_text[16];
        static char hum_text[16];
        sprintf(temp_text, "%.1f °C", temp);
        sprintf(hum_text, "%.1f %%", hum);

        lv_label_set_text(ui_tempData, temp_text);
        lv_label_set_text(ui_humData, hum_text);
        lv_bar_set_value(ui_tempBar, (int)temp, LV_ANIM_ON);
        lv_bar_set_value(ui_humBar, (int)hum, LV_ANIM_ON);

        Serial.print("온도: ");
        Serial.print(temp);
        Serial.print(" °C, 습도: ");
        Serial.print(hum);
        Serial.println(" %");
    }
}

void update_Sensor_Data(lv_event_t * e)
{
    Serial.println("홈 화면 로드 완료 - 온습도 데이터 수집 시작...");
    dht.begin();
    lv_timer_create(update_temp_hum, 2000, NULL);
}

// 릴레이 제어를 위한 명령어 정의
#define CMD_FAN_ON    'F'
#define CMD_FAN_OFF   'f'
#define CMD_LED_ON    'L'
#define CMD_LED_OFF   'l'
#define CMD_HUM_ON    'H'
#define CMD_HUM_OFF   'h'

// 릴레이 상태 변수
static bool fan_state = false;
static bool led_state = false;
static bool hum_state = false;

void ui_event_ControlLeftDown(lv_event_t * e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    if(event_code == LV_EVENT_CLICKED) {
        // 팬 제어 명령 전송
        fan_state = !fan_state;
        sendCommand(fan_state ? CMD_FAN_ON : CMD_FAN_OFF);
        fan_request_pending = true;
        fan_last_request = millis();
        
        // 상태 확인 타이머 시작 (없으면 생성)
        static lv_timer_t * fan_timer = NULL;
        if (fan_timer == NULL) {
            fan_timer = lv_timer_create(request_fan_status, 100, NULL);
        }
    }
}

void request_fan_status(lv_timer_t * timer) {
    if (fan_request_pending && millis() - fan_last_request >= 100) {
        Wire.requestFrom(SLAVE_ADDR, 1);
        if (Wire.available()) {
            byte status = Wire.read();
            bool actual_fan_state = (status & 0x0C) != 0;
            
            // UI 업데이트
            static lv_style_t style_pressed;
            lv_style_init(&style_pressed);
            lv_style_set_img_recolor_opa(&style_pressed, 255);
            lv_style_set_img_recolor(&style_pressed, actual_fan_state ? lv_color_hex(0x00FF00) : lv_color_hex(0x808080));
            
            lv_obj_add_style(ui_ControlLeftDown, &style_pressed, 0);
            
            // 상태가 확인되면 pending 플래그 해제
            fan_request_pending = false;
            
            // 타이머 삭제
            lv_timer_del(timer);
        }
    }
}

void ui_event_ControlRightDown(lv_event_t * e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    if(event_code == LV_EVENT_CLICKED) {
        // LED 제어 명령 전송
        led_state = !led_state;
        sendCommand(led_state ? CMD_LED_ON : CMD_LED_OFF);
        led_request_pending = true;
        led_last_request = millis();
        
        // 상태 확인 타이머 시작 (없으면 생성)
        static lv_timer_t * led_timer = NULL;
        if (led_timer == NULL) {
            led_timer = lv_timer_create(request_led_status, 100, NULL);
        }
    }
}

void request_led_status(lv_timer_t * timer) {
    if (led_request_pending && millis() - led_last_request >= 100) {
        Wire.requestFrom(SLAVE_ADDR, 1);
        if (Wire.available()) {
            byte status = Wire.read();
            bool actual_led_state = (status & 0xF0) != 0;
            
            // UI 업데이트
            static lv_style_t style_pressed;
            lv_style_init(&style_pressed);
            lv_style_set_img_recolor_opa(&style_pressed, 255);
            lv_style_set_img_recolor(&style_pressed, actual_led_state ? lv_color_hex(0x00FF00) : lv_color_hex(0x808080));
            
            lv_obj_add_style(ui_ControlRightDown, &style_pressed, 0);
            
            // 상태가 확인되면 pending 플래그 해제
            led_request_pending = false;
            
            // 타이머 삭제
            lv_timer_del(timer);
        }
    }
}

void ui_event_ControlRightUp(lv_event_t * e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    if(event_code == LV_EVENT_CLICKED) {
        // 가습기 제어 명령 전송
        hum_state = !hum_state;
        sendCommand(hum_state ? CMD_HUM_ON : CMD_HUM_OFF);
        hum_request_pending = true;
        hum_last_request = millis();
        
        // 상태 확인 타이머 시작 (없으면 생성)
        static lv_timer_t * hum_timer = NULL;
        if (hum_timer == NULL) {
            hum_timer = lv_timer_create(request_hum_status, 100, NULL);
        }
    }
}

void request_hum_status(lv_timer_t * timer) {
    if (hum_request_pending && millis() - hum_last_request >= 100) {
        Wire.requestFrom(SLAVE_ADDR, 1);
        if (Wire.available()) {
            byte status = Wire.read();
            bool actual_hum_state = (status & 0x03) != 0;
            
            // UI 업데이트
            static lv_style_t style_pressed;
            lv_style_init(&style_pressed);
            lv_style_set_img_recolor_opa(&style_pressed, 255);
            lv_style_set_img_recolor(&style_pressed, actual_hum_state ? lv_color_hex(0x00FF00) : lv_color_hex(0x808080));
            
            lv_obj_add_style(ui_ControlRightUp, &style_pressed, 0);
            
            // 상태가 확인되면 pending 플래그 해제
            hum_request_pending = false;
            
            // 타이머 삭제
            lv_timer_del(timer);
        }
    }
}

// I2Cub97c ud1b5ud574 Arduinouc5d0 uba85ub839 uc804uc1a1
void sendCommand(char command) {
    Wire.beginTransmission(SLAVE_ADDR);
    Wire.write(command);
    Wire.endTransmission();
    
    // ub514ubc84uae45uc6a9 ub85cuadf8
    Serial.print("Command sent: ");
    Serial.println(command);
}

// 타이머 변수 선언 추가
static lv_timer_t * fan_timer = NULL;
static lv_timer_t * led_timer = NULL;
static lv_timer_t * hum_timer = NULL;

void ui_event_ControlLeftUp(lv_event_t * e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    if(event_code == LV_EVENT_CLICKED) {
        // 뒤로가기
        lv_disp_t * d = lv_disp_get_default();
        lv_screen_load_anim(ui_home, LV_SCR_LOAD_ANIM_MOVE_LEFT, 150, 0, false);
    }
}
